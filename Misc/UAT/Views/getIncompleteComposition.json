{"name":"getIncompleteComposition","category":"view","description":null,"metaData":"{\n    \"parameters\": [\n        {\n            \"name\": \"formName\",\n            \"description\": \"\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"maxDate\",\n            \"description\": \"\",\n            \"type\": \"string\"\n        }\n    ]\n}","steps":[{"processorName":"js","processorData":"function generateTaggedByQuery(formNames) {\n    var splitNames = formNames.split(',');\n    var query = '';\n    for (var i in splitNames) {\n        query += \"c TAGGED BY 'formName::\" + splitNames[i] + \"'\";\n        if (i < splitNames.length - 1) {\n            query += \" or \";\n        }\n    }\n    return query;\n}\n\nfunction generateAql(formNames) {\n    var taggedBy = generateTaggedByQuery(formNames);\n    return \"SELECT c/uid/value as compositionId, \" +\n            \" c/composer/name as composer, \" +\n            \" v/commit_audit/time_committed/value as compositionSaved, \" +\n            \" v/lifecycle_state/value as lifecycleState, \" +\n            \" tags(c) as tagInfo\" +\n            \" FROM EHR e[ehr_id/value=:ehrId]\" +\n            \" CONTAINS COMPOSITION c\" +\n            \" CONTAINS VERSIONED_OBJECT vo\" +\n            \" CONTAINS VERSION v\" +\n            \" WHERE (\" + taggedBy + \")\" +\n            \" AND not c TAGGED BY 'permanentlyIncomplete'\" +\n            \" AND v/lifecycle_state matches {'incomplete'}\" +\n            \" AND compositionSaved > :maxDate\" +\n            \" ORDER BY v/commit_audit/time_committed/value DESC\";\n}\n\nfunction parseResult(results) {\n    var outputObject = {};\n    var formName;\n    for (var i in results) {\n        formName = getFormNameTag(results[i].tagInfo.tags);\n        if (!outputObject[formName]) {\n            outputObject[formName] = results[i];\n        }\n    }\n    return outputObject;\n}\n\nfunction getFormNameTag(tags) {\n    for (var i in tags) {\n        if (tags[i].tag === 'formName') {\n            return tags[i].value;\n        }\n    }\n    return '';\n}\n\nfunction compute(ctx, src) { \n    var promises = {\n        incompleteComposition: Ehr.query({\n            aql: generateAql(ctx.vars.formName),\n            initvalue: [],\n            params: {\n                ehrId: ctx.vars.ehrId,\n                formName: ctx.vars.formName,\n                maxDate: ctx.vars.maxDate\n            },\n            callback: function (out, result) {\n                out.push(result);\n            }\n        })\n    };\n\n    var result = {};\n    Ehr.allhash(promises, function (res) {\n        result = parseResult(res['incompleteComposition']);\n    });\n    return result;\n}"}]}