{"name":"getPatientAssessments","category":"view","description":null,"metaData":"{\n    \"parameters\": [\n        {\n            \"name\": \"templates\",\n            \"description\": \"\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"searchTerms\",\n            \"description\": \"\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"incompleteMaxDate\",\n            \"description\": \"\",\n            \"type\": \"string\"\n        }\n    ]\n}","steps":[{"processorName":"js","processorData":"function generateAql(templates, searchTerms) {\n    var termsString = \"\";\n    if (searchTerms) {\n        termsString = \"AND (title LIKE \" + searchTerms + \" OR creator LIKE \" + searchTerms + \" OR created LIKE \" + searchTerms + \")\";\n    }\n\n    return \"SELECT c/name/value as title, \\n\" +\n        \"   c/uid/value as uid, \\n\" +\n        \"   c/context/start_time/value as startTime, \\n\" +\n        \"   c/archetype_details/template_id/value as templateId, \\n\" +\n        \"   c/composer/name as creator, \\n\" +\n        \"   v/commit_audit/time_committed/value as created, \\n\" +\n        \"   tags(c) as tagData, \\n\" +\n        \"   vo/trunk_lifecycle_state/value as status \\n\" +\n        \"   FROM EHR e [ehr_id/value=:ehrId] \\n\" +\n        \"   CONTAINS VERSIONED_OBJECT vo CONTAINS VERSION v[all_versions] \\n\" +\n        \"   CONTAINS COMPOSITION c \\n\" +\n        \"   WHERE v/lifecycle_state matches {'complete'} \\n\" +\n        \"   AND templateId matches {\" + templates + \"} \\n\" +\n        termsString +\n        \"   ORDER BY created DESC\";\n}\n\nfunction generateIncompleteCompositionsAql() {\n  return 'SELECT c/name/value as title, '+\n  ' c/uid/value as uid, ' +\n  'c/context/start_time/value as startTime, c/archetype_details/template_id/value as templateId,' +\n  ' c/composer/name as creator, v/commit_audit/time_committed/value as created, tags(c) as tagData' +\n  ' FROM EHR e[ehr_id/value=:ehrId]' +\n  ' CONTAINS COMPOSITION c' +\n  ' CONTAINS VERSIONED_OBJECT vo' +\n  ' CONTAINS VERSION v' +\n  ' WHERE (c TAGGED BY \"permanentlyIncomplete\" AND v/lifecycle_state matches {\"incomplete\"})' +\n  ' OR (v/lifecycle_state matches {\"incomplete\"} AND v/commit_audit/time_committed/value < :incompleteMaxDate )' +\n  ' ORDER BY v/commit_audit/time_committed/value';\n}\n\nfunction generateDeletedCompositionsAql(versionedCompositionIds) {\n    return  'SELECT vo/uid/value as versionedUid, ' +\n    '   v/lifecycle_state/value as status, ' +\n    '   v/commit_audit/description/value as comment, ' + \n    '   v/uid/value as uid, ' +\n    '   v/commit_audit/committer/name as creator, ' +\n    '   v/commit_audit/time_committed/value as createTime, ' +\n    '   v/lifecycle_state/value as lifecycleState ' +\n    '   FROM EHR e ' +\n    '   CONTAINS VERSIONED_OBJECT vo ' +\n    '   CONTAINS VERSION v[all_versions] ' +\n    '   WHERE v/uid/value matches { ' + versionedCompositionIds + '}';\n}\n\nfunction generateEhrQuery(ctx, templates, searchTerms) {\n    return Ehr.query({\n        aql: generateAql(templates, searchTerms),\n        initvalue: [],\n        params: {\n            ehrId: ctx.vars.ehrId,\n        },\n        callback: function (out, result) {\n            out.push(result);\n        }\n    });\n}\n\nfunction generateIncompleteEhrQuery(ctx) {\n    return Ehr.query({\n        aql: generateIncompleteCompositionsAql(),\n        initvalue: [],\n        params: {\n            ehrId: ctx.vars.ehrId,\n            incompleteMaxDate: ctx.vars.incompleteMaxDate\n        },\n        callback: function (out, result) {\n            out.push(result);\n        }\n    });\n}\n\nfunction generateDeletedVersionsQuery(ctx, deletedDocuments) {\n    var deletedUids = '';\n    var deletedDocumentKeys = Object.keys(deletedDocuments);\n    if (!deletedDocumentKeys.length) {\n        return null;\n    }\n    for (var doc in deletedDocumentKeys) {\n        var uid = deletedDocuments[deletedDocumentKeys[doc]].uid.split('::');\n        uid[2] = +uid[2] + 1;\n        deletedUids += \"'\" + uid.join('::') + \"'\";\n        if (doc < deletedDocumentKeys.length - 1) {\n            deletedUids += ',';\n        }\n    }\n    return [Ehr.query({\n        aql: generateDeletedCompositionsAql(deletedUids),\n        initvalue: [],\n        params: {\n            ehrId: ctx.vars.ehrId,\n        },\n        callback: function (out, result) {\n            out.push(result);\n        }\n    })];\n}\n\n// Filters versions of compositions and only returns the latest version for each compositionUid\nfunction extractLatestVersions(compositions) {\n    var latestVersions = {};\n    var latestCompositions = [];\n    for (var c in compositions) {\n        var composition = compositions[c];\n        var uidElements = composition.uid.split('::');\n        var uid = uidElements[0];\n        var version = uidElements[2];\n        composition.version = +version;\n        var compositionDataToCompare = latestVersions[uid];\n        if (!compositionDataToCompare) {\n            latestVersions[uid] = composition;\n        } else if (compositionDataToCompare.version < composition.version) {\n            latestVersions[uid] = composition;\n        }\n    }\n    for (var i in Object.keys(latestVersions)) {\n        latestCompositions.push(latestVersions[Object.keys(latestVersions)[i]]);\n    }\n    return latestCompositions;\n}\n\nfunction compute(ctx, src) {\n    var templates;\n    var searchTerms = '';\n    var templatesString = '';\n\n    if (ctx.vars.templates) {\n        templates = ctx.vars.templates;\n        templates = templates.split(',');\n        for(var t in templates) {\n            templatesString = templatesString + '\"' + templates[t] + '\"';\n            if (t < templates.length - 1) {\n                templatesString = templatesString + ',';\n            }\n        }\n    }\n\n    if (ctx.vars.searchTerms) {\n        searchTerms = ctx.vars.searchTerms;\n    }\n\n    var documents = [];\n    var promises = {};\n\n    promises = {\n        complete: generateEhrQuery(ctx, templatesString, searchTerms),\n        incomplete: generateIncompleteEhrQuery(ctx)\n    };\n\n    Ehr.allhash(promises, function (res) {\n        documents = res;\n    });\n\n    var completeDocuments = extractLatestVersions(documents.complete);\n    var incompleteDocuments = documents.incomplete;\n\n    for (var i in incompleteDocuments) {\n        incompleteDocuments[i].type = 'draft';\n    }\n    for (var i in completeDocuments) {\n        completeDocuments[i].type = 'composition';\n    }\n\n    // Pop deleted documents into separate object with uid keys\n    var deletedDocuments = {};\n    for (var doc = 0; doc < completeDocuments.length; doc++) {\n        if (completeDocuments[doc].status === 'deleted') {\n            var deletedUid = completeDocuments[doc].uid.split('::')[0];\n            deletedDocuments[deletedUid] = completeDocuments[doc];\n            completeDocuments.splice(doc, 1);\n        }\n    }\n\n    var deletedVersionsPromise = generateDeletedVersionsQuery(ctx, deletedDocuments);\n    if (deletedVersionsPromise) {\n    // Loads latest versions for deleted compositions and modifies previous deleted documents\n    Ehr.allhash(deletedVersionsPromise, function(res) {\n        for (var r in res[0]) {\n            var document = res[0][r];\n            var documentUid = document.uid.split('::')[0];\n            deletedDocuments[documentUid].creator = document.creator;\n            deletedDocuments[documentUid].createTime = document.createTime;\n            deletedDocuments[documentUid].comment = document.comment;\n        }\n        });\n    }\n    // Re-merge deleted documents from object to original array\n    var deletedDocumentKeys = Object.keys(deletedDocuments);\n    for (var document in deletedDocumentKeys) {\n        completeDocuments.push(deletedDocuments[deletedDocumentKeys[document]]);\n    }\n    return completeDocuments.concat(incompleteDocuments);\n}\n"}]}